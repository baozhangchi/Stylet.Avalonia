using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Stylet.Avalonia.CodeGenerator;

[Generator(LanguageNames.CSharp)]
public partial class StyletCodeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        RegisterExtensionsGenerator(context);
        RegisterBaseTypesGenerator(context);
        RegisterViewModelsGenerator(context);

        context.RegisterSourceOutput(context.CompilationProvider, (sourceProductionContext, compilation) =>
        {
            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                var semanticModel = compilation.GetSemanticModel(syntaxTree);
                foreach (var declarationSyntax in syntaxTree.GetCompilationUnitRoot().DescendantNodes()
                             .OfType<ClassDeclarationSyntax>())
                {
                    var declaredSymbol = semanticModel.GetDeclaredSymbol(declarationSyntax);
                    if (declaredSymbol != null &&
                        declaredSymbol.AllInterfaces.Any(x => x.Name == "INotifyPropertyChanged") &&
                        !declaredSymbol.InheritsFrom("Stylet.PropertyChangedBase"))
                    {
                        var className = declaredSymbol.Name;
                        var ns = declaredSymbol.ContainingNamespace.ToDisplayString();
                        var classDeclarationSyntax = SyntaxFactory.ClassDeclaration(className)
                            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                            .AddAttributeLists(SyntaxFactory.AttributeList(
                                SyntaxFactory.SeparatedList(new List<AttributeSyntax>
                                {
                                    SyntaxFactory.Attribute(
                                        SyntaxFactory.ParseName("DoNotNotify"))
                                })));
                        sourceProductionContext.AddSource($"{className}.g.cs",
                            GenerateFullCode(ns, classDeclarationSyntax, "PropertyChanged"));
                    }
                }
            }
        });
    }

    private static BlockSyntax GenerateMethodBody(params string[] statements)
    {
        return SyntaxFactory.Block(statements.Select(x => SyntaxFactory.ParseStatement(x)));
    }

    private static string GenerateFullCode(string @namespace, ClassDeclarationSyntax classDeclarationSyntax,
        params string[] usings)
    {
        var compilationUnitSyntax = SyntaxFactory.CompilationUnit()
            .AddUsings(usings.Select(x => SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(x))).ToArray())
            .AddMembers(SyntaxFactory.FileScopedNamespaceDeclaration(SyntaxFactory.ParseName(@namespace))
                .AddMembers(classDeclarationSyntax));
        return
            $"// <auto-generated />\r\n#nullable enable\r\n\r\n{compilationUnitSyntax.NormalizeWhitespace().ToFullString()}";
    }

    private static MethodDeclarationSyntax GenerateMethod(string methodName, string returnTypeName,
        MethodModifier modifier, params string[] statements)
    {
        return SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(returnTypeName),
                SyntaxFactory.Identifier(methodName)).AddModifiers(modifier.ToTokens())
            .WithBody(GenerateMethodBody(statements));
    }

    private static MethodDeclarationSyntax GenerateMethod(string methodName, string returnTypeName,
        MethodModifier modifier, Dictionary<string, string> typeParameters,
        Dictionary<string, (string Type, bool fromThis)> parameters,
        params string[] statements)
    {
        var typeParameterList = SyntaxFactory.TypeParameterList();
        if (typeParameters.Any())
            typeParameterList = SyntaxFactory.TypeParameterList(SyntaxFactory.Token(SyntaxKind.LessThanToken),
                SyntaxFactory.SeparatedList(typeParameters.Keys.Select(SyntaxFactory.TypeParameter).ToList()),
                SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        var constraintClauses = SyntaxFactory.List<TypeParameterConstraintClauseSyntax>();
        if (typeParameters.Any())
            constraintClauses = SyntaxFactory.List(
                typeParameters.Select(x =>
                    SyntaxFactory.TypeParameterConstraintClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword),
                        SyntaxFactory.IdentifierName(x.Key), SyntaxFactory.Token(SyntaxKind.ColonToken),
                        SyntaxFactory.SeparatedList(new List<TypeParameterConstraintSyntax>(x.Value.Split(',', ' ')
                            .Select(_ =>
                                SyntaxFactory.TypeConstraint(SyntaxFactory.ParseTypeName(_)))))))
            );

        var parameterList = SyntaxFactory.ParameterList();
        if (parameters.Any())
            parameterList = SyntaxFactory.ParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenToken),
                SyntaxFactory.SeparatedList(parameters.Select(x =>
                    SyntaxFactory.Parameter(SyntaxFactory.List<AttributeListSyntax>(),
                        x.Value.fromThis
                            ? SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                            : SyntaxFactory.TokenList(), SyntaxFactory.ParseTypeName(x.Value.Type),
                        SyntaxFactory.Identifier(x.Key), null))
                ),
                SyntaxFactory.Token(SyntaxKind.CloseParenToken));

        return SyntaxFactory.MethodDeclaration(SyntaxFactory.List<AttributeListSyntax>(),
            SyntaxFactory.TokenList(), SyntaxFactory.ParseTypeName(returnTypeName),
            null!,
            SyntaxFactory.Identifier(methodName),
            typeParameterList,
            parameterList,
            constraintClauses, GenerateMethodBody(statements),
            SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken)).AddModifiers(modifier.ToTokens());
    }

    private static MethodDeclarationSyntax GenerateMethod(string methodName, string returnTypeName,
        MethodModifier modifier,
        Dictionary<string, (string Type, bool fromThis)> parameters,
        params string[] statements)
    {
        var parameterList = SyntaxFactory.ParameterList();
        if (parameters.Any())
            parameterList = SyntaxFactory.ParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenToken),
                SyntaxFactory.SeparatedList(parameters.Select(x =>
                    SyntaxFactory.Parameter(SyntaxFactory.List<AttributeListSyntax>(),
                        x.Value.fromThis
                            ? SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.ThisKeyword))
                            : SyntaxFactory.TokenList(), SyntaxFactory.ParseTypeName(x.Value.Type),
                        SyntaxFactory.Identifier(x.Key), null))
                ),
                SyntaxFactory.Token(SyntaxKind.CloseParenToken));
        return SyntaxFactory
            .MethodDeclaration(SyntaxFactory.ParseTypeName(returnTypeName), SyntaxFactory.Identifier(methodName))
            .WithParameterList(parameterList).WithBody(GenerateMethodBody(statements))
            .AddModifiers(modifier.ToTokens());
    }
}